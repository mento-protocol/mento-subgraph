// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal,
} from "@graphprotocol/graph-ts";

export class Account extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Account entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Account must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Account", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Account | null {
    return changetype<Account | null>(
      store.get_in_block("Account", id.toHexString()),
    );
  }

  static load(id: Bytes): Account | null {
    return changetype<Account | null>(store.get("Account", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asVoting(): Bytes | null {
    let value = this.get("asVoting");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set asVoting(value: Bytes | null) {
    if (!value) {
      this.unset("asVoting");
    } else {
      this.set("asVoting", Value.fromBytes(<Bytes>value));
    }
  }

  get delegationFrom(): VoteDelegationLoader {
    return new VoteDelegationLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "delegationFrom",
    );
  }

  get delegationTo(): VoteDelegationLoader {
    return new VoteDelegationLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "delegationTo",
    );
  }

  get voteWeigth(): VoteWeightLoader {
    return new VoteWeightLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "voteWeigth",
    );
  }

  get delegateChangedEvent(): DelegateChangedLoader {
    return new DelegateChangedLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "delegateChangedEvent",
    );
  }

  get delegateChangedFromEvent(): DelegateChangedLoader {
    return new DelegateChangedLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "delegateChangedFromEvent",
    );
  }

  get delegateChangedToEvent(): DelegateChangedLoader {
    return new DelegateChangedLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "delegateChangedToEvent",
    );
  }

  get delegateVotesChangedEvent(): DelegateVotesChangedLoader {
    return new DelegateVotesChangedLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "delegateVotesChangedEvent",
    );
  }

  get asLocking(): Bytes | null {
    let value = this.get("asLocking");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set asLocking(value: Bytes | null) {
    if (!value) {
      this.unset("asLocking");
    } else {
      this.set("asLocking", Value.fromBytes(<Bytes>value));
    }
  }

  get locks(): LockLoader {
    return new LockLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "locks",
    );
  }

  get asTimelock(): Bytes | null {
    let value = this.get("asTimelock");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set asTimelock(value: Bytes | null) {
    if (!value) {
      this.unset("asTimelock");
    } else {
      this.set("asTimelock", Value.fromBytes(<Bytes>value));
    }
  }

  get timelockedCalls(): TimelockCallLoader {
    return new TimelockCallLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "timelockedCalls",
    );
  }

  get asAccessControl(): Bytes | null {
    let value = this.get("asAccessControl");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set asAccessControl(value: Bytes | null) {
    if (!value) {
      this.unset("asAccessControl");
    } else {
      this.set("asAccessControl", Value.fromBytes(<Bytes>value));
    }
  }

  get membership(): AccessControlRoleMemberLoader {
    return new AccessControlRoleMemberLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "membership",
    );
  }

  get roleGranted(): RoleGrantedLoader {
    return new RoleGrantedLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "roleGranted",
    );
  }

  get roleGrantedSender(): RoleGrantedLoader {
    return new RoleGrantedLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "roleGrantedSender",
    );
  }

  get roleRevoked(): RoleRevokedLoader {
    return new RoleRevokedLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "roleRevoked",
    );
  }

  get roleRevokedSender(): RoleRevokedLoader {
    return new RoleRevokedLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "roleRevokedSender",
    );
  }

  get asGovernor(): Bytes | null {
    let value = this.get("asGovernor");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set asGovernor(value: Bytes | null) {
    if (!value) {
      this.unset("asGovernor");
    } else {
      this.set("asGovernor", Value.fromBytes(<Bytes>value));
    }
  }

  get proposed(): ProposalLoader {
    return new ProposalLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "proposed",
    );
  }

  get voted(): VoteReceiptLoader {
    return new VoteReceiptLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "voted",
    );
  }

  get proposedCalls(): ProposalCallLoader {
    return new ProposalCallLoader(
      "Account",
      this.get("id")!.toBytes().toHexString(),
      "proposedCalls",
    );
  }
}

export class VotingContract extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VotingContract entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type VotingContract must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("VotingContract", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): VotingContract | null {
    return changetype<VotingContract | null>(
      store.get_in_block("VotingContract", id.toHexString()),
    );
  }

  static load(id: Bytes): VotingContract | null {
    return changetype<VotingContract | null>(
      store.get("VotingContract", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asAccount(): Bytes {
    let value = this.get("asAccount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set asAccount(value: Bytes) {
    this.set("asAccount", Value.fromBytes(value));
  }

  get totalWeight(): string {
    let value = this.get("totalWeight");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set totalWeight(value: string) {
    this.set("totalWeight", Value.fromString(value));
  }

  get weight(): VoteWeightLoader {
    return new VoteWeightLoader(
      "VotingContract",
      this.get("id")!.toBytes().toHexString(),
      "weight",
    );
  }

  get delegation(): VoteDelegationLoader {
    return new VoteDelegationLoader(
      "VotingContract",
      this.get("id")!.toBytes().toHexString(),
      "delegation",
    );
  }

  get delegateChangedEvent(): DelegateChangedLoader {
    return new DelegateChangedLoader(
      "VotingContract",
      this.get("id")!.toBytes().toHexString(),
      "delegateChangedEvent",
    );
  }

  get delegateVotesChangedEvent(): DelegateVotesChangedLoader {
    return new DelegateVotesChangedLoader(
      "VotingContract",
      this.get("id")!.toBytes().toHexString(),
      "delegateVotesChangedEvent",
    );
  }
}

export class VoteDelegation extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VoteDelegation entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VoteDelegation must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("VoteDelegation", id.toString(), this);
    }
  }

  static loadInBlock(id: string): VoteDelegation | null {
    return changetype<VoteDelegation | null>(
      store.get_in_block("VoteDelegation", id),
    );
  }

  static load(id: string): VoteDelegation | null {
    return changetype<VoteDelegation | null>(store.get("VoteDelegation", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get delegator(): Bytes {
    let value = this.get("delegator");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set delegator(value: Bytes) {
    this.set("delegator", Value.fromBytes(value));
  }

  get delegatee(): Bytes {
    let value = this.get("delegatee");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set delegatee(value: Bytes) {
    this.set("delegatee", Value.fromBytes(value));
  }

  get delegateChangedEvent(): DelegateChangedLoader {
    return new DelegateChangedLoader(
      "VoteDelegation",
      this.get("id")!.toString(),
      "delegateChangedEvent",
    );
  }
}

export class VoteWeight extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VoteWeight entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VoteWeight must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("VoteWeight", id.toString(), this);
    }
  }

  static loadInBlock(id: string): VoteWeight | null {
    return changetype<VoteWeight | null>(store.get_in_block("VoteWeight", id));
  }

  static load(id: string): VoteWeight | null {
    return changetype<VoteWeight | null>(store.get("VoteWeight", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get account(): Bytes | null {
    let value = this.get("account");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set account(value: Bytes | null) {
    if (!value) {
      this.unset("account");
    } else {
      this.set("account", Value.fromBytes(<Bytes>value));
    }
  }

  get value(): BigInt {
    let value = this.get("value");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }

  get delegateVotesChangedEvent(): DelegateVotesChangedLoader {
    return new DelegateVotesChangedLoader(
      "VoteWeight",
      this.get("id")!.toString(),
      "delegateVotesChangedEvent",
    );
  }
}

export class DelegateChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DelegateChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DelegateChanged must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("DelegateChanged", id.toString(), this);
    }
  }

  static loadInBlock(id: string): DelegateChanged | null {
    return changetype<DelegateChanged | null>(
      store.get_in_block("DelegateChanged", id),
    );
  }

  static load(id: string): DelegateChanged | null {
    return changetype<DelegateChanged | null>(store.get("DelegateChanged", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get delegation(): string | null {
    let value = this.get("delegation");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set delegation(value: string | null) {
    if (!value) {
      this.unset("delegation");
    } else {
      this.set("delegation", Value.fromString(<string>value));
    }
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get delegator(): Bytes {
    let value = this.get("delegator");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set delegator(value: Bytes) {
    this.set("delegator", Value.fromBytes(value));
  }

  get fromDelegate(): Bytes {
    let value = this.get("fromDelegate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set fromDelegate(value: Bytes) {
    this.set("fromDelegate", Value.fromBytes(value));
  }

  get toDelegate(): Bytes {
    let value = this.get("toDelegate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set toDelegate(value: Bytes) {
    this.set("toDelegate", Value.fromBytes(value));
  }
}

export class DelegateVotesChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DelegateVotesChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DelegateVotesChanged must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("DelegateVotesChanged", id.toString(), this);
    }
  }

  static loadInBlock(id: string): DelegateVotesChanged | null {
    return changetype<DelegateVotesChanged | null>(
      store.get_in_block("DelegateVotesChanged", id),
    );
  }

  static load(id: string): DelegateVotesChanged | null {
    return changetype<DelegateVotesChanged | null>(
      store.get("DelegateVotesChanged", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get voteWeight(): string | null {
    let value = this.get("voteWeight");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set voteWeight(value: string | null) {
    if (!value) {
      this.unset("voteWeight");
    } else {
      this.set("voteWeight", Value.fromString(<string>value));
    }
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get delegate(): Bytes {
    let value = this.get("delegate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set delegate(value: Bytes) {
    this.set("delegate", Value.fromBytes(value));
  }

  get oldValue(): BigInt {
    let value = this.get("oldValue");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set oldValue(value: BigInt) {
    this.set("oldValue", Value.fromBigInt(value));
  }

  get newValue(): BigInt {
    let value = this.get("newValue");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set newValue(value: BigInt) {
    this.set("newValue", Value.fromBigInt(value));
  }
}

export class Locking extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Locking entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Locking must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Locking", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Locking | null {
    return changetype<Locking | null>(
      store.get_in_block("Locking", id.toHexString()),
    );
  }

  static load(id: Bytes): Locking | null {
    return changetype<Locking | null>(store.get("Locking", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asAccount(): Bytes {
    let value = this.get("asAccount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set asAccount(value: Bytes) {
    this.set("asAccount", Value.fromBytes(value));
  }

  get mode(): string | null {
    let value = this.get("mode");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set mode(value: string | null) {
    if (!value) {
      this.unset("mode");
    } else {
      this.set("mode", Value.fromString(<string>value));
    }
  }

  get locks(): LockLoader {
    return new LockLoader(
      "Locking",
      this.get("id")!.toBytes().toHexString(),
      "locks",
    );
  }

  get lockCreate(): LockCreateLoader {
    return new LockCreateLoader(
      "Locking",
      this.get("id")!.toBytes().toHexString(),
      "lockCreate",
    );
  }

  get relock(): RelockLoader {
    return new RelockLoader(
      "Locking",
      this.get("id")!.toBytes().toHexString(),
      "relock",
    );
  }

  get delegate(): DelegateLoader {
    return new DelegateLoader(
      "Locking",
      this.get("id")!.toBytes().toHexString(),
      "delegate",
    );
  }

  get withdraw(): WithdrawLoader {
    return new WithdrawLoader(
      "Locking",
      this.get("id")!.toBytes().toHexString(),
      "withdraw",
    );
  }
}

export class Lock extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Lock entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Lock must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Lock", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Lock | null {
    return changetype<Lock | null>(store.get_in_block("Lock", id));
  }

  static load(id: string): Lock | null {
    return changetype<Lock | null>(store.get("Lock", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get locking(): Bytes {
    let value = this.get("locking");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set locking(value: Bytes) {
    this.set("locking", Value.fromBytes(value));
  }

  get lockId(): BigInt {
    let value = this.get("lockId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lockId(value: BigInt) {
    this.set("lockId", Value.fromBigInt(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get delegate(): Bytes {
    let value = this.get("delegate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set delegate(value: Bytes) {
    this.set("delegate", Value.fromBytes(value));
  }

  get time(): BigInt {
    let value = this.get("time");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set time(value: BigInt) {
    this.set("time", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get slope(): i32 {
    let value = this.get("slope");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set slope(value: i32) {
    this.set("slope", Value.fromI32(value));
  }

  get cliff(): i32 {
    let value = this.get("cliff");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set cliff(value: i32) {
    this.set("cliff", Value.fromI32(value));
  }

  get replacedBy(): string | null {
    let value = this.get("replacedBy");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set replacedBy(value: string | null) {
    if (!value) {
      this.unset("replacedBy");
    } else {
      this.set("replacedBy", Value.fromString(<string>value));
    }
  }

  get replaces(): string | null {
    let value = this.get("replaces");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set replaces(value: string | null) {
    if (!value) {
      this.unset("replaces");
    } else {
      this.set("replaces", Value.fromString(<string>value));
    }
  }

  get relocked(): boolean {
    let value = this.get("relocked");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set relocked(value: boolean) {
    this.set("relocked", Value.fromBoolean(value));
  }

  get lockCreate(): LockCreateLoader {
    return new LockCreateLoader(
      "Lock",
      this.get("id")!.toString(),
      "lockCreate",
    );
  }

  get relock(): RelockLoader {
    return new RelockLoader("Lock", this.get("id")!.toString(), "relock");
  }
}

export class LockCreate extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LockCreate entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LockCreate must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("LockCreate", id.toString(), this);
    }
  }

  static loadInBlock(id: string): LockCreate | null {
    return changetype<LockCreate | null>(store.get_in_block("LockCreate", id));
  }

  static load(id: string): LockCreate | null {
    return changetype<LockCreate | null>(store.get("LockCreate", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get locking(): Bytes {
    let value = this.get("locking");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set locking(value: Bytes) {
    this.set("locking", Value.fromBytes(value));
  }

  get lock(): string {
    let value = this.get("lock");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lock(value: string) {
    this.set("lock", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }
}

export class Relock extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Relock entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Relock must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Relock", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Relock | null {
    return changetype<Relock | null>(store.get_in_block("Relock", id));
  }

  static load(id: string): Relock | null {
    return changetype<Relock | null>(store.get("Relock", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get locking(): Bytes {
    let value = this.get("locking");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set locking(value: Bytes) {
    this.set("locking", Value.fromBytes(value));
  }

  get newLock(): string {
    let value = this.get("newLock");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set newLock(value: string) {
    this.set("newLock", Value.fromString(value));
  }

  get oldLock(): string {
    let value = this.get("oldLock");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set oldLock(value: string) {
    this.set("oldLock", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }
}

export class Delegate extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Delegate entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Delegate must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Delegate", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Delegate | null {
    return changetype<Delegate | null>(store.get_in_block("Delegate", id));
  }

  static load(id: string): Delegate | null {
    return changetype<Delegate | null>(store.get("Delegate", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get locking(): Bytes {
    let value = this.get("locking");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set locking(value: Bytes) {
    this.set("locking", Value.fromBytes(value));
  }

  get lock(): string {
    let value = this.get("lock");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lock(value: string) {
    this.set("lock", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get delegate(): Bytes {
    let value = this.get("delegate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set delegate(value: Bytes) {
    this.set("delegate", Value.fromBytes(value));
  }
}

export class Withdraw extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Withdraw entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Withdraw must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Withdraw", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Withdraw | null {
    return changetype<Withdraw | null>(store.get_in_block("Withdraw", id));
  }

  static load(id: string): Withdraw | null {
    return changetype<Withdraw | null>(store.get("Withdraw", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get locking(): Bytes {
    let value = this.get("locking");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set locking(value: Bytes) {
    this.set("locking", Value.fromBytes(value));
  }

  get lock(): string {
    let value = this.get("lock");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lock(value: string) {
    this.set("lock", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class Timelock extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Timelock entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Timelock must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Timelock", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Timelock | null {
    return changetype<Timelock | null>(
      store.get_in_block("Timelock", id.toHexString()),
    );
  }

  static load(id: Bytes): Timelock | null {
    return changetype<Timelock | null>(store.get("Timelock", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asAccount(): Bytes {
    let value = this.get("asAccount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set asAccount(value: Bytes) {
    this.set("asAccount", Value.fromBytes(value));
  }

  get operations(): TimelockOperationLoader {
    return new TimelockOperationLoader(
      "Timelock",
      this.get("id")!.toBytes().toHexString(),
      "operations",
    );
  }

  get scheduled(): TimelockOperationScheduledLoader {
    return new TimelockOperationScheduledLoader(
      "Timelock",
      this.get("id")!.toBytes().toHexString(),
      "scheduled",
    );
  }

  get executed(): TimelockOperationExecutedLoader {
    return new TimelockOperationExecutedLoader(
      "Timelock",
      this.get("id")!.toBytes().toHexString(),
      "executed",
    );
  }

  get cancelled(): TimelockOperationCancelledLoader {
    return new TimelockOperationCancelledLoader(
      "Timelock",
      this.get("id")!.toBytes().toHexString(),
      "cancelled",
    );
  }

  get mindelaychange(): TimelockMinDelayChangeLoader {
    return new TimelockMinDelayChangeLoader(
      "Timelock",
      this.get("id")!.toBytes().toHexString(),
      "mindelaychange",
    );
  }
}

export class TimelockOperation extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TimelockOperation entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TimelockOperation must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("TimelockOperation", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TimelockOperation | null {
    return changetype<TimelockOperation | null>(
      store.get_in_block("TimelockOperation", id),
    );
  }

  static load(id: string): TimelockOperation | null {
    return changetype<TimelockOperation | null>(
      store.get("TimelockOperation", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get status(): string {
    let value = this.get("status");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set status(value: string) {
    this.set("status", Value.fromString(value));
  }

  get delay(): BigInt {
    let value = this.get("delay");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set delay(value: BigInt) {
    this.set("delay", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get predecessor(): string | null {
    let value = this.get("predecessor");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set predecessor(value: string | null) {
    if (!value) {
      this.unset("predecessor");
    } else {
      this.set("predecessor", Value.fromString(<string>value));
    }
  }

  get calls(): TimelockCallLoader {
    return new TimelockCallLoader(
      "TimelockOperation",
      this.get("id")!.toString(),
      "calls",
    );
  }

  get scheduled(): TimelockOperationScheduledLoader {
    return new TimelockOperationScheduledLoader(
      "TimelockOperation",
      this.get("id")!.toString(),
      "scheduled",
    );
  }

  get executed(): TimelockOperationExecutedLoader {
    return new TimelockOperationExecutedLoader(
      "TimelockOperation",
      this.get("id")!.toString(),
      "executed",
    );
  }

  get cancelled(): TimelockOperationCancelledLoader {
    return new TimelockOperationCancelledLoader(
      "TimelockOperation",
      this.get("id")!.toString(),
      "cancelled",
    );
  }
}

export class TimelockCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TimelockCall entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TimelockCall must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("TimelockCall", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TimelockCall | null {
    return changetype<TimelockCall | null>(
      store.get_in_block("TimelockCall", id),
    );
  }

  static load(id: string): TimelockCall | null {
    return changetype<TimelockCall | null>(store.get("TimelockCall", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get operation(): string {
    let value = this.get("operation");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set operation(value: string) {
    this.set("operation", Value.fromString(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get target(): Bytes {
    let value = this.get("target");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set target(value: Bytes) {
    this.set("target", Value.fromBytes(value));
  }

  get value(): BigDecimal {
    let value = this.get("value");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set value(value: BigDecimal) {
    this.set("value", Value.fromBigDecimal(value));
  }

  get data(): Bytes {
    let value = this.get("data");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set data(value: Bytes) {
    this.set("data", Value.fromBytes(value));
  }

  get scheduled(): TimelockOperationScheduledLoader {
    return new TimelockOperationScheduledLoader(
      "TimelockCall",
      this.get("id")!.toString(),
      "scheduled",
    );
  }

  get executed(): TimelockOperationExecutedLoader {
    return new TimelockOperationExecutedLoader(
      "TimelockCall",
      this.get("id")!.toString(),
      "executed",
    );
  }
}

export class TimelockOperationScheduled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save TimelockOperationScheduled entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TimelockOperationScheduled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("TimelockOperationScheduled", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TimelockOperationScheduled | null {
    return changetype<TimelockOperationScheduled | null>(
      store.get_in_block("TimelockOperationScheduled", id),
    );
  }

  static load(id: string): TimelockOperationScheduled | null {
    return changetype<TimelockOperationScheduled | null>(
      store.get("TimelockOperationScheduled", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get operation(): string {
    let value = this.get("operation");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set operation(value: string) {
    this.set("operation", Value.fromString(value));
  }

  get call(): string {
    let value = this.get("call");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set call(value: string) {
    this.set("call", Value.fromString(value));
  }
}

export class TimelockOperationExecuted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save TimelockOperationExecuted entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TimelockOperationExecuted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("TimelockOperationExecuted", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TimelockOperationExecuted | null {
    return changetype<TimelockOperationExecuted | null>(
      store.get_in_block("TimelockOperationExecuted", id),
    );
  }

  static load(id: string): TimelockOperationExecuted | null {
    return changetype<TimelockOperationExecuted | null>(
      store.get("TimelockOperationExecuted", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get operation(): string {
    let value = this.get("operation");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set operation(value: string) {
    this.set("operation", Value.fromString(value));
  }

  get call(): string {
    let value = this.get("call");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set call(value: string) {
    this.set("call", Value.fromString(value));
  }
}

export class TimelockOperationCancelled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save TimelockOperationCancelled entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TimelockOperationCancelled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("TimelockOperationCancelled", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TimelockOperationCancelled | null {
    return changetype<TimelockOperationCancelled | null>(
      store.get_in_block("TimelockOperationCancelled", id),
    );
  }

  static load(id: string): TimelockOperationCancelled | null {
    return changetype<TimelockOperationCancelled | null>(
      store.get("TimelockOperationCancelled", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get operation(): string {
    let value = this.get("operation");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set operation(value: string) {
    this.set("operation", Value.fromString(value));
  }
}

export class TimelockMinDelayChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save TimelockMinDelayChange entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TimelockMinDelayChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("TimelockMinDelayChange", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TimelockMinDelayChange | null {
    return changetype<TimelockMinDelayChange | null>(
      store.get_in_block("TimelockMinDelayChange", id),
    );
  }

  static load(id: string): TimelockMinDelayChange | null {
    return changetype<TimelockMinDelayChange | null>(
      store.get("TimelockMinDelayChange", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get delay(): BigInt {
    let value = this.get("delay");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set delay(value: BigInt) {
    this.set("delay", Value.fromBigInt(value));
  }
}

export class AccessControl extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AccessControl entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AccessControl must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AccessControl", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AccessControl | null {
    return changetype<AccessControl | null>(
      store.get_in_block("AccessControl", id.toHexString()),
    );
  }

  static load(id: Bytes): AccessControl | null {
    return changetype<AccessControl | null>(
      store.get("AccessControl", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asAccount(): Bytes {
    let value = this.get("asAccount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set asAccount(value: Bytes) {
    this.set("asAccount", Value.fromBytes(value));
  }

  get roles(): AccessControlRoleLoader {
    return new AccessControlRoleLoader(
      "AccessControl",
      this.get("id")!.toBytes().toHexString(),
      "roles",
    );
  }
}

export class Role extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Role entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Role must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Role", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Role | null {
    return changetype<Role | null>(
      store.get_in_block("Role", id.toHexString()),
    );
  }

  static load(id: Bytes): Role | null {
    return changetype<Role | null>(store.get("Role", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get roleOf(): AccessControlRoleLoader {
    return new AccessControlRoleLoader(
      "Role",
      this.get("id")!.toBytes().toHexString(),
      "roleOf",
    );
  }
}

export class AccessControlRole extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AccessControlRole entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AccessControlRole must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AccessControlRole", id.toString(), this);
    }
  }

  static loadInBlock(id: string): AccessControlRole | null {
    return changetype<AccessControlRole | null>(
      store.get_in_block("AccessControlRole", id),
    );
  }

  static load(id: string): AccessControlRole | null {
    return changetype<AccessControlRole | null>(
      store.get("AccessControlRole", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get role(): Bytes {
    let value = this.get("role");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set role(value: Bytes) {
    this.set("role", Value.fromBytes(value));
  }

  get admin(): string {
    let value = this.get("admin");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set admin(value: string) {
    this.set("admin", Value.fromString(value));
  }

  get adminOf(): AccessControlRoleLoader {
    return new AccessControlRoleLoader(
      "AccessControlRole",
      this.get("id")!.toString(),
      "adminOf",
    );
  }

  get members(): AccessControlRoleMemberLoader {
    return new AccessControlRoleMemberLoader(
      "AccessControlRole",
      this.get("id")!.toString(),
      "members",
    );
  }

  get roleGranted(): RoleGrantedLoader {
    return new RoleGrantedLoader(
      "AccessControlRole",
      this.get("id")!.toString(),
      "roleGranted",
    );
  }

  get roleRevoked(): RoleRevokedLoader {
    return new RoleRevokedLoader(
      "AccessControlRole",
      this.get("id")!.toString(),
      "roleRevoked",
    );
  }

  get roleAdminChanged(): RoleAdminChangedLoader {
    return new RoleAdminChangedLoader(
      "AccessControlRole",
      this.get("id")!.toString(),
      "roleAdminChanged",
    );
  }
}

export class AccessControlRoleMember extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save AccessControlRoleMember entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AccessControlRoleMember must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AccessControlRoleMember", id.toString(), this);
    }
  }

  static loadInBlock(id: string): AccessControlRoleMember | null {
    return changetype<AccessControlRoleMember | null>(
      store.get_in_block("AccessControlRoleMember", id),
    );
  }

  static load(id: string): AccessControlRoleMember | null {
    return changetype<AccessControlRoleMember | null>(
      store.get("AccessControlRoleMember", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get accesscontrolrole(): string {
    let value = this.get("accesscontrolrole");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set accesscontrolrole(value: string) {
    this.set("accesscontrolrole", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }
}

export class RoleAdminChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RoleAdminChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RoleAdminChanged must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("RoleAdminChanged", id.toString(), this);
    }
  }

  static loadInBlock(id: string): RoleAdminChanged | null {
    return changetype<RoleAdminChanged | null>(
      store.get_in_block("RoleAdminChanged", id),
    );
  }

  static load(id: string): RoleAdminChanged | null {
    return changetype<RoleAdminChanged | null>(
      store.get("RoleAdminChanged", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get role(): string {
    let value = this.get("role");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set role(value: string) {
    this.set("role", Value.fromString(value));
  }

  get newAdminRole(): string {
    let value = this.get("newAdminRole");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set newAdminRole(value: string) {
    this.set("newAdminRole", Value.fromString(value));
  }

  get previousAdminRole(): string {
    let value = this.get("previousAdminRole");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set previousAdminRole(value: string) {
    this.set("previousAdminRole", Value.fromString(value));
  }
}

export class RoleGranted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RoleGranted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RoleGranted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("RoleGranted", id.toString(), this);
    }
  }

  static loadInBlock(id: string): RoleGranted | null {
    return changetype<RoleGranted | null>(
      store.get_in_block("RoleGranted", id),
    );
  }

  static load(id: string): RoleGranted | null {
    return changetype<RoleGranted | null>(store.get("RoleGranted", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get role(): string {
    let value = this.get("role");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set role(value: string) {
    this.set("role", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }
}

export class RoleRevoked extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RoleRevoked entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RoleRevoked must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("RoleRevoked", id.toString(), this);
    }
  }

  static loadInBlock(id: string): RoleRevoked | null {
    return changetype<RoleRevoked | null>(
      store.get_in_block("RoleRevoked", id),
    );
  }

  static load(id: string): RoleRevoked | null {
    return changetype<RoleRevoked | null>(store.get("RoleRevoked", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get role(): string {
    let value = this.get("role");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set role(value: string) {
    this.set("role", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }
}

export class Governor extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Governor entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Governor must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Governor", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Governor | null {
    return changetype<Governor | null>(
      store.get_in_block("Governor", id.toHexString()),
    );
  }

  static load(id: Bytes): Governor | null {
    return changetype<Governor | null>(store.get("Governor", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asAccount(): Bytes {
    let value = this.get("asAccount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set asAccount(value: Bytes) {
    this.set("asAccount", Value.fromBytes(value));
  }

  get mode(): string | null {
    let value = this.get("mode");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set mode(value: string | null) {
    if (!value) {
      this.unset("mode");
    } else {
      this.set("mode", Value.fromString(<string>value));
    }
  }

  get proposals(): ProposalLoader {
    return new ProposalLoader(
      "Governor",
      this.get("id")!.toBytes().toHexString(),
      "proposals",
    );
  }

  get proposalCreated(): ProposalCreatedLoader {
    return new ProposalCreatedLoader(
      "Governor",
      this.get("id")!.toBytes().toHexString(),
      "proposalCreated",
    );
  }

  get proposalQueued(): ProposalQueuedLoader {
    return new ProposalQueuedLoader(
      "Governor",
      this.get("id")!.toBytes().toHexString(),
      "proposalQueued",
    );
  }

  get proposalExecuted(): ProposalExecutedLoader {
    return new ProposalExecutedLoader(
      "Governor",
      this.get("id")!.toBytes().toHexString(),
      "proposalExecuted",
    );
  }

  get proposalCanceled(): ProposalCanceledLoader {
    return new ProposalCanceledLoader(
      "Governor",
      this.get("id")!.toBytes().toHexString(),
      "proposalCanceled",
    );
  }

  get votecast(): VoteCastLoader {
    return new VoteCastLoader(
      "Governor",
      this.get("id")!.toBytes().toHexString(),
      "votecast",
    );
  }
}

export class Proposal extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Proposal entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Proposal must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Proposal", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Proposal | null {
    return changetype<Proposal | null>(store.get_in_block("Proposal", id));
  }

  static load(id: string): Proposal | null {
    return changetype<Proposal | null>(store.get("Proposal", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposalId(): BigInt {
    let value = this.get("proposalId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set proposalId(value: BigInt) {
    this.set("proposalId", Value.fromBigInt(value));
  }

  get proposer(): Bytes {
    let value = this.get("proposer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set proposer(value: Bytes) {
    this.set("proposer", Value.fromBytes(value));
  }

  get startBlock(): BigInt {
    let value = this.get("startBlock");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set startBlock(value: BigInt) {
    this.set("startBlock", Value.fromBigInt(value));
  }

  get endBlock(): BigInt {
    let value = this.get("endBlock");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set endBlock(value: BigInt) {
    this.set("endBlock", Value.fromBigInt(value));
  }

  get description(): string {
    let value = this.get("description");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set description(value: string) {
    this.set("description", Value.fromString(value));
  }

  get eta(): BigInt | null {
    let value = this.get("eta");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set eta(value: BigInt | null) {
    if (!value) {
      this.unset("eta");
    } else {
      this.set("eta", Value.fromBigInt(<BigInt>value));
    }
  }

  get canceled(): boolean {
    let value = this.get("canceled");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set canceled(value: boolean) {
    this.set("canceled", Value.fromBoolean(value));
  }

  get queued(): boolean {
    let value = this.get("queued");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set queued(value: boolean) {
    this.set("queued", Value.fromBoolean(value));
  }

  get executed(): boolean {
    let value = this.get("executed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set executed(value: boolean) {
    this.set("executed", Value.fromBoolean(value));
  }

  get calls(): ProposalCallLoader {
    return new ProposalCallLoader(
      "Proposal",
      this.get("id")!.toString(),
      "calls",
    );
  }

  get supports(): ProposalSupportLoader {
    return new ProposalSupportLoader(
      "Proposal",
      this.get("id")!.toString(),
      "supports",
    );
  }

  get receipts(): VoteReceiptLoader {
    return new VoteReceiptLoader(
      "Proposal",
      this.get("id")!.toString(),
      "receipts",
    );
  }

  get proposalCreated(): ProposalCreatedLoader {
    return new ProposalCreatedLoader(
      "Proposal",
      this.get("id")!.toString(),
      "proposalCreated",
    );
  }

  get proposalQueued(): ProposalQueuedLoader {
    return new ProposalQueuedLoader(
      "Proposal",
      this.get("id")!.toString(),
      "proposalQueued",
    );
  }

  get proposalExecuted(): ProposalExecutedLoader {
    return new ProposalExecutedLoader(
      "Proposal",
      this.get("id")!.toString(),
      "proposalExecuted",
    );
  }

  get proposalCanceled(): ProposalCanceledLoader {
    return new ProposalCanceledLoader(
      "Proposal",
      this.get("id")!.toString(),
      "proposalCanceled",
    );
  }

  get votecast(): VoteCastLoader {
    return new VoteCastLoader(
      "Proposal",
      this.get("id")!.toString(),
      "votecast",
    );
  }
}

export class ProposalCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalCall entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalCall must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ProposalCall", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ProposalCall | null {
    return changetype<ProposalCall | null>(
      store.get_in_block("ProposalCall", id),
    );
  }

  static load(id: string): ProposalCall | null {
    return changetype<ProposalCall | null>(store.get("ProposalCall", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get index(): i32 {
    let value = this.get("index");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set index(value: i32) {
    this.set("index", Value.fromI32(value));
  }

  get target(): Bytes {
    let value = this.get("target");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set target(value: Bytes) {
    this.set("target", Value.fromBytes(value));
  }

  get value(): BigDecimal {
    let value = this.get("value");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set value(value: BigDecimal) {
    this.set("value", Value.fromBigDecimal(value));
  }

  get signature(): string {
    let value = this.get("signature");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set signature(value: string) {
    this.set("signature", Value.fromString(value));
  }

  get calldata(): Bytes {
    let value = this.get("calldata");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set calldata(value: Bytes) {
    this.set("calldata", Value.fromBytes(value));
  }
}

export class ProposalSupport extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalSupport entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalSupport must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ProposalSupport", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ProposalSupport | null {
    return changetype<ProposalSupport | null>(
      store.get_in_block("ProposalSupport", id),
    );
  }

  static load(id: string): ProposalSupport | null {
    return changetype<ProposalSupport | null>(store.get("ProposalSupport", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get support(): i32 {
    let value = this.get("support");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set support(value: i32) {
    this.set("support", Value.fromI32(value));
  }

  get weight(): BigInt {
    let value = this.get("weight");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set weight(value: BigInt) {
    this.set("weight", Value.fromBigInt(value));
  }

  get votes(): VoteReceiptLoader {
    return new VoteReceiptLoader(
      "ProposalSupport",
      this.get("id")!.toString(),
      "votes",
    );
  }
}

export class VoteReceipt extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VoteReceipt entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VoteReceipt must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("VoteReceipt", id.toString(), this);
    }
  }

  static loadInBlock(id: string): VoteReceipt | null {
    return changetype<VoteReceipt | null>(
      store.get_in_block("VoteReceipt", id),
    );
  }

  static load(id: string): VoteReceipt | null {
    return changetype<VoteReceipt | null>(store.get("VoteReceipt", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get voter(): Bytes {
    let value = this.get("voter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set voter(value: Bytes) {
    this.set("voter", Value.fromBytes(value));
  }

  get support(): string {
    let value = this.get("support");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set support(value: string) {
    this.set("support", Value.fromString(value));
  }

  get weight(): BigInt {
    let value = this.get("weight");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set weight(value: BigInt) {
    this.set("weight", Value.fromBigInt(value));
  }

  get reason(): string {
    let value = this.get("reason");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set reason(value: string) {
    this.set("reason", Value.fromString(value));
  }

  get params(): Bytes | null {
    let value = this.get("params");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set params(value: Bytes | null) {
    if (!value) {
      this.unset("params");
    } else {
      this.set("params", Value.fromBytes(<Bytes>value));
    }
  }
}

export class ProposalCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ProposalCreated", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ProposalCreated | null {
    return changetype<ProposalCreated | null>(
      store.get_in_block("ProposalCreated", id),
    );
  }

  static load(id: string): ProposalCreated | null {
    return changetype<ProposalCreated | null>(store.get("ProposalCreated", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get proposer(): Bytes {
    let value = this.get("proposer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set proposer(value: Bytes) {
    this.set("proposer", Value.fromBytes(value));
  }
}

export class ProposalQueued extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalQueued entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalQueued must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ProposalQueued", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ProposalQueued | null {
    return changetype<ProposalQueued | null>(
      store.get_in_block("ProposalQueued", id),
    );
  }

  static load(id: string): ProposalQueued | null {
    return changetype<ProposalQueued | null>(store.get("ProposalQueued", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get eta(): BigInt {
    let value = this.get("eta");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set eta(value: BigInt) {
    this.set("eta", Value.fromBigInt(value));
  }
}

export class ProposalExecuted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalExecuted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalExecuted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ProposalExecuted", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ProposalExecuted | null {
    return changetype<ProposalExecuted | null>(
      store.get_in_block("ProposalExecuted", id),
    );
  }

  static load(id: string): ProposalExecuted | null {
    return changetype<ProposalExecuted | null>(
      store.get("ProposalExecuted", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }
}

export class ProposalCanceled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalCanceled entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalCanceled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ProposalCanceled", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ProposalCanceled | null {
    return changetype<ProposalCanceled | null>(
      store.get_in_block("ProposalCanceled", id),
    );
  }

  static load(id: string): ProposalCanceled | null {
    return changetype<ProposalCanceled | null>(
      store.get("ProposalCanceled", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }
}

export class VoteCast extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VoteCast entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VoteCast must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("VoteCast", id.toString(), this);
    }
  }

  static loadInBlock(id: string): VoteCast | null {
    return changetype<VoteCast | null>(store.get_in_block("VoteCast", id));
  }

  static load(id: string): VoteCast | null {
    return changetype<VoteCast | null>(store.get("VoteCast", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get support(): string {
    let value = this.get("support");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set support(value: string) {
    this.set("support", Value.fromString(value));
  }

  get receipt(): string {
    let value = this.get("receipt");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set receipt(value: string) {
    this.set("receipt", Value.fromString(value));
  }

  get voter(): Bytes {
    let value = this.get("voter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set voter(value: Bytes) {
    this.set("voter", Value.fromBytes(value));
  }
}

export class Transaction extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Transaction entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Transaction must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Transaction", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Transaction | null {
    return changetype<Transaction | null>(
      store.get_in_block("Transaction", id),
    );
  }

  static load(id: string): Transaction | null {
    return changetype<Transaction | null>(store.get("Transaction", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }
}

export class VoteDelegationLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): VoteDelegation[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<VoteDelegation[]>(value);
  }
}

export class VoteWeightLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): VoteWeight[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<VoteWeight[]>(value);
  }
}

export class DelegateChangedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): DelegateChanged[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<DelegateChanged[]>(value);
  }
}

export class DelegateVotesChangedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): DelegateVotesChanged[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<DelegateVotesChanged[]>(value);
  }
}

export class LockLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Lock[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Lock[]>(value);
  }
}

export class TimelockCallLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TimelockCall[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TimelockCall[]>(value);
  }
}

export class AccessControlRoleMemberLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AccessControlRoleMember[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AccessControlRoleMember[]>(value);
  }
}

export class RoleGrantedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): RoleGranted[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<RoleGranted[]>(value);
  }
}

export class RoleRevokedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): RoleRevoked[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<RoleRevoked[]>(value);
  }
}

export class ProposalLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Proposal[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Proposal[]>(value);
  }
}

export class VoteReceiptLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): VoteReceipt[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<VoteReceipt[]>(value);
  }
}

export class ProposalCallLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ProposalCall[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ProposalCall[]>(value);
  }
}

export class LockCreateLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): LockCreate[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<LockCreate[]>(value);
  }
}

export class RelockLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Relock[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Relock[]>(value);
  }
}

export class DelegateLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Delegate[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Delegate[]>(value);
  }
}

export class WithdrawLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Withdraw[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Withdraw[]>(value);
  }
}

export class TimelockOperationLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TimelockOperation[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TimelockOperation[]>(value);
  }
}

export class TimelockOperationScheduledLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TimelockOperationScheduled[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TimelockOperationScheduled[]>(value);
  }
}

export class TimelockOperationExecutedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TimelockOperationExecuted[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TimelockOperationExecuted[]>(value);
  }
}

export class TimelockOperationCancelledLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TimelockOperationCancelled[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TimelockOperationCancelled[]>(value);
  }
}

export class TimelockMinDelayChangeLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TimelockMinDelayChange[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TimelockMinDelayChange[]>(value);
  }
}

export class AccessControlRoleLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AccessControlRole[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AccessControlRole[]>(value);
  }
}

export class RoleAdminChangedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): RoleAdminChanged[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<RoleAdminChanged[]>(value);
  }
}

export class ProposalCreatedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ProposalCreated[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ProposalCreated[]>(value);
  }
}

export class ProposalQueuedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ProposalQueued[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ProposalQueued[]>(value);
  }
}

export class ProposalExecutedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ProposalExecuted[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ProposalExecuted[]>(value);
  }
}

export class ProposalCanceledLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ProposalCanceled[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ProposalCanceled[]>(value);
  }
}

export class VoteCastLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): VoteCast[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<VoteCast[]>(value);
  }
}

export class ProposalSupportLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ProposalSupport[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ProposalSupport[]>(value);
  }
}
